---
title: "Title TBD"
bibliography: CogSci2022-giannino.bib
csl: apa6.csl
document-params: "10pt, letterpaper"

author-information: >
  \author{Kennedy Casey \\
          University of Chicago \\
          \texttt{\small{kbcasey@uchicago.edu}}
  \And \textbf{Mary Elliott} \\
               University of Texas at Dallas \\
               \texttt{\small{maryle18@gmail.com}}
  \And \textbf{Anapaula Silva Mandujano} \\
               University of Chicago \\
               \texttt{\small{anapaula@uchicago.edu}}   
  \And \textbf{Kimberly Shorter} \\
               University of Chicago \\
               \texttt{\small{klshorter@uchicago.edu}}
  \AND \textbf{Elizabeth Mickiewicz} \\
               University of Chicago \\
               \texttt{\small{lizmick9@uchicago.edu}}         
  \And \textbf{Mara Duquette} \\
               University of Chicago \\
               \texttt{\small{duquettemara@uchicago.edu}}
  \And \textbf{Elika Bergelson} \\
               Duke University \\
               \texttt{\small{elika.bergelson@duke.edu}}
  \And \textbf{Marisa Casillas} \\
               University of Chicago \\
               \texttt{\small{mcasillas@uchicago.edu}}}

abstract:

keywords:
    
output: cogsci2016::cogsci_paper
final-submission: \cogscifinalcopy
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(fig.width = 3, fig.height = 3, fig.crop  =  FALSE, 
                      fig.pos  =  "tb", fig.path = 'figs/',
                      echo = FALSE, warning = FALSE, cache = FALSE, 
                      message = FALSE, sanitize = TRUE)
```

```{r, libraries}
library(tidyverse)
library(lubridate)
library(broom)
library(broom.mixed)
library(lme4)
library(lmerTest)
library(gghalves)
library(cowplot)
library(ggpubr)
library(ggeffects)
library(xtable)
```

```{r, data-prep}

run.from.raw = FALSE
if (run.from.raw) {
  # this R script generates the usable data csv
  # set run.from.raw equal to TRUE if you want to rewrite this file
  source("../data-prep.R")
} 

# read in data
raw.data <- read_csv("../data/usable.data_20220117.csv")

# pre-set colors and category labels
sites <- c("Rossel", "Tseltal")

site.colors <- c("Rossel" = "#3C5388", 
                 "Tseltal" = "#02A087")

categories <- c("Synthetic", "Food", "Tool", 
                "Toy", "Natural", "Immovable")

# rm excluded photos + set other variable info
data <- raw.data %>%
  # TO DO: fix NAs in site and category
  filter(!is.na(site) & !is.na(object_type) & is.na(exclusion)) %>%
    mutate(hour = hour(timestamp),
           object_type = factor(object_type, 
                       levels = c("Other Synthetic Object", "Food", "Tool", 
                                  "Toy", "Other Natural Object", "Large Immovable"),
                       labels = categories))
```

# Introduction

The artifacts of everyday life reflect our routines, aspirations, relationships, and more. In particular, the objects that we regularly pick up and handle---a coffee cup, a laptop, a baby bottle---offer a window into the physical, social, and cultural contexts that shape our understanding of the world. In this paper, we take a glimpse into everyday life at its beginnings by exploring object handling at home by children from early infancy until age four. We contextualize our study with respect to the effects of object-centric interaction on word learning, though we note that different analyses of these same data could shed new light on other types of social learning as well as motor development [see @herzberg2021exuberant on the latter point].
<!--mc: for future writing, as far as i can tell, this general area is called material culture studies and is an interdisciplinary field with archeology, anthropology, and sociology. i need to do more reading!!-->

## Object handling and word learning

For young learners, objects and their associated activities form a critical source of input for social learning, including the ways in which children are exposed to language about those objects. Hands (and what they are handling) can be reliable indicators of what someone is doing and talking about during object play<!--mc: NB: we look at a lot more than play and i'm not sure how well this idea generalizes, especially across cultures! but that's an issue for another day. or rather another fieldtrip. someday :*-) -->, facilitating children's ability to map word forms onto their meanings in and across real-time interaction [e.g., @yu2013joint; @yurovsky2013statistical]. Present, attended-to objects also influence the babble of children who have acquired stable consonants [@laing2020babble]. Further, caregivers' tendency to use nouns referring to objects in the here-and-now positively predicts their children's early word comprehension [@bergelson2017nature].

How frequently do children engage in object-centric interactions? Hands---others' and their own---are in good supply in young children's view of the world, especially after early infancy [@fausey2016faces; @jayaraman2017faces; @long2020detecting], topping out at visible presence ~30% of the time. Infants own object handling is also relatively frequent: Herzberg and colleagues [-@herzberg2021exuberant] find that US infants handle objects ~60% of the time during at-home play, Yu and colleagues [-@yu2013joint] find ~70% when including joint handling with adults in US in-lab object play, and @casillasURdaylong find ~15 and ~17% object handling in daylong photo streams in a Papuan and a Mayan community, respectively. Note, however, that _labeling_ of object-relevant features (e.g., its name and associated concepts) is the critical second ingredient relevant for word learning, which may only occur during a small subset of total object handling time. Additionally, the likelihood of talk about objects that are being handled in the here and now---a flagship feature of contingent caregiver talk [e.g., @mcgillion2013supporting]---fluctuates across high and low activity periods of interaction [@bergelson2019day].

Overall, while prior work makes a strong case for the impact of children's object-centric interactions on their word learning, the findings: (a) are limited to a culturally narrow sample of populations, (b) have tended to rely on short recordings that limit the scope of object-centered interactions analyzed, and (c) have rarely examined in detail the distributions of individual objects children typically interact with at home [exceptions include @bergelson2019day, @casillasURdaylong, and @herzberg2021exuberant].

## Object handling across age and culture

Children's object handling input changes enormously across the first few years due to both maturational constraints and culture-specific caregiving practices. In early infancy, children have little ability to hold things or to control their posture, primarily experiencing objects through what others bring near to them (faces may make up a much greater proportion of their social input at this point; @fausey2016faces; @jayaraman2017faces, but see @long2020detecting). However, later gains in manual dexterity and gross motor skill (e.g., sitting, crawling, walking) increasingly widen their ability to seek, reach, and grab a diversity of objects in their environment<!--mc: :P ---including those meant to be out of reach, EDNA--> and give them greater control over what they handle, how they elicit social information relating to that object, and for how long [@adolph2010motor; @herzberg2021exuberant; @gaskins2000childrens; @kretch2014crawling; @sanchez2018detecting].

Early access to objects is also shaped by culture-specific practices for carrying children, keeping them safe and warm, and scaffolding the development of locally valued capacities (e.g., word learning in many US families, walking in Kenyan Kipsigis families, @super1976environmental, see @adolph2010motor for an overview). The array of objects available to children will also vary in type and prevalence crossculturally, including: (a) objects spread via globalization (e.g., plastic bags), (b) objects that have a basic functional role that has arisen similarly across many groups (e.g., spoon-like things for eating), and (c) objects are specific to people and places (e.g., the gourd and bombilla for drinking mate in much of South America, stemming from Indigenous Guaraní and Tupí tradition). Take, for example, middle-class US family homes, which have been noted for their large quantities of possessions ("clutter"), much of which is designed specifically for children (e.g., toys and books @arnold2012life). We might infer, based on this distribution, that much of what children do and talk about at home is tailored to what particularly interests them. And thus the children's worlds, in this sense, look very different from their caregivers'. Recent work by Herzberg and colleagues [-@herzberg2021exuberant] underscores this point with infancy data; 13--23-month-olds spent nearly 70% of their time in object play with toys or a mix of toys and non-toys, with ~100% of infants playing with children's books and stuffed animals and a total of 32 toy types appearing in $\ge$ 25% of infants' play. Non-toy play was also common, but still appeared to predominantly include infant-specific objects (e.g., sippy cups, baby spoons, high chairs, pacifiers). We would expect many of these items to be rare in other parts of the world, with much greater overlap between objects for infants and objects for adults (e.g., @karasik2018not).

<!--
mc: open question to co-authors...
are the two subsections above in the right order? should it be switched around? something else? i've tried it both ways and neither seems perfect
-->

## The current study

Using daylong photo streams from child-worn cameras, we analyze object handling by children under age four in two rural, small-scale subsistence farming communities from opposite sides of the globe: Rossel Island ("Rossel"; Milne Bay Province, Papua New Guinea) and Tenejapa ("Tseltal"; Chiapas, Mexico). While these communities are comparable in many ways (e.g., rural, swidden horticulturalist, housed in multi-generation family complexes), prior work has established substantial differences in the organization of young children's daily lives, child carrying practices, and each community's level of market integration (e.g., the greater availability of synthetic materials in Tenejapa), leading us to expect differences in what children handle across the day and early lifespan [@brownIPchildrearing; @casillasURdaylong; @casillas2020early; @casillas2021early]. We first establish how often children handle objects from different categories, both by object category (e.g., food vs. tools) and by number of unique objects per hour in each category across sites. We explore the top individual objects in each site and how much overlap there is in these objects between settings. Finally, we investigate whether the prevalence of object holding in each category changes linearly across the day or with developmental age, as predicted in prior work (morning mealtimes: @casillas2020early; @casillas2021early and increased handling activity with age: @casillasURdaylong).

Annotation is ongoing (see Method), but preliminary findings reveal relative consistency in the broad composition of objects children handle between sites and across the day, with a few important exceptions: a greater diversity of synthetic objects per hour for Tseltal children (e.g., relating to greater market integration), more time spent with immovable objects for Rossel children (e.g., relating to socializing time on/near household verandas), greater overall prevalence of food handling in the mornings, and a greater diversity of held objects with developmental age. We discuss open questions and potential implications of these findings for early word learning.

# Method
## Corpus
These daylong photo streams consist of images captured every 15 (Rossel) to 30 (Tseltal) seconds over the course of, typically, 8 (Rossel) to 9 (Tseltal) hours at home. Children wore a recording vest equipped with a camera (Narrative Clip 1) and miniature fisheye lens (Photojojo Super Fisheye) that provided a 180$\text{\textdegree}$ view of the environment. For younger infants who were not yet walking, the camera was instead worn by the primary caregiver. Previously, 83 daylong photo streams (113668 photos) had been comprehensively manually annotated for the presence of child object handling [@casillasURdaylong]; we further annotate and analyze this subset of `r raw.data %>% select(sub_num, image) %>% distinct %>% nrow()` photos in the present study.

```{r, demo}
# create tibbles with basic descriptive stats of kid demographics and # images
demo.bysite <- data %>%
  group_by(site, sub_num, age) %>%
  summarize(n.images = length(unique(image))) %>%
  group_by(site) %>%
  summarize(n.kids = length(unique(sub_num)), 
            m.images = mean(n.images),
            m.age = mean(age))

demo <- data %>%
  group_by(sub_num, age) %>%
  summarize(n.images = n()) %>%
  ungroup() %>%
  summarize(min.images = min(n.images), 
            max.images = max(n.images), 
            mean.images = mean(n.images),
            median.images = median(n.images),
            min.age = min(age), 
            max.age = max(age),
            n.kids = length(unique(sub_num)))
```

The present data include images from one photo stream each of `r demo$n.kids` children <!--kc: reminder to myself to make sure to randomly select 1 directory for the kids that have 2 in data prep--> (Rossel: `r subset(demo.bysite, site == "Rossel")$n.kids`, Tseltal: `r subset(demo.bysite, site == "Tseltal")$n.kids`) ranging in age from `r demo$min.age` to `r demo$max.age` months (_M_~_Rossel_~ = `r round(subset(demo.bysite, site == "Rossel")$m.age, 1)`, _M_~_Tseltal_~ = `r round(subset(demo.bysite, site == "Tseltal")$m.age, 1)`). The number of photos featuring child object handling per child ranged from `r demo$min.images` to `r demo$max.images` (_M_~_Rossel_~ = `r round(subset(demo.bysite, site == "Rossel")$m.images, 1)`, _M_~_Tseltal_~ = `r round(subset(demo.bysite, site == "Tseltal")$m.images, 1)`). <!--kc: consider dropping kids with very few images or reporting median which is more representative-->

## Manual annotation
We annotated photos with ImCo (version 2; [https://github.com/kennedycasey/ImCo2](https://github.com/kennedycasey/ImCo2)), an open-source Python application adapted for efficient coding of image streams <!--kc: will make repo public next week; rm link for blind review?; mc2kc: we already chatted and you probably just didn't have a chance to update this, but no need to keep the link removed/private bc we're identifiable enough just based on the populations under study! and you're not saying this is "our" software so it's fine-->. Annotators provided labels for the handled object(s) present in each photo (e.g., "twig") and selected among predefined categories to characterize each type of object in the image (e.g., "natural object"). Categories included food, tools, toys, immovable objects, natural objects, and miscellaneous synthetic objects (see Table \ref{tab:top-objects} for example objects from each category).

## Reliability
XX% of photo streams were double coded. Reliability annotations were equally spread across sites and ages. At the category level, annotators agreed on XX.X% of decisions (Rossel: XX.X%, Tseltal: XX.X%). At the object label level, annotators agreed on XX.X% of decisions (Rossel: XX.X%). <!--kc: will probably need some description of common discrepancies and more details about manual collapsing across similar labels; mc2kc: we can keep this very minimal if we're low on space--> To avoid unnecessary data loss, all excluded photos were checked by at least one other annotator and re-included for analysis if objects were identifiable. <!--kc: need to add manual checking procedure here or above-->

```{r, top-objects, results = "asis"}
# compute the objects that most often appear 1+ times across children w/i sites
# use this to find the top 3 items per category per site
# create a table displaying these top items
top.objects.bycategory <- data %>%
  select(site, object_type, object, sub_num) %>%
  distinct() %>%
  group_by(site) %>%
  summarize(total = length(unique(sub_num)), 
            object_type = object_type, 
            object = object, 
            sub_num = sub_num) %>%
  distinct() %>% # <- mc2kc: not doing anything, i think, but left just in case
  group_by(site, object_type, object, total) %>%
  summarize(n.children = length(unique(sub_num))) %>%
  mutate(prop.children = n.children/total) %>%
  ungroup() %>%
  arrange(site, object_type, desc(prop.children)) %>%
  group_by(site, object_type) %>%
  mutate(rank = row_number()) %>%
  filter(rank %in% 1:3) %>%
  select(-n.children, -prop.children) %>%
  pivot_wider(names_from = "rank", values_from = "object") %>%
  mutate(objects = paste0(`1`, ", ", `2`, ", ", `3`)) %>%
  select(object_type, objects, site) %>%
  group_by(object_type) %>%
  pivot_wider(names_from = "site", values_from = "objects") %>%
  rename(`Object Category` = object_type)

top.objects.tbl <- xtable(top.objects.bycategory, caption = "Objects handled by the most children across categories and sites.", label = "tab:top-objects")

print(top.objects.tbl, type = "latex", comment = FALSE, table.placement = "!ht", scalebox = 0.8, include.rownames = FALSE)
```

# Results
## Overall frequency statistics
```{r, daily-object-stats, results = "hide"}
# compute descriptive stats of # unique objects held by individual kids

# ... overall
daily.objects <- data %>%
  group_by(sub_num) %>%
  summarize(n.objects = length(unique(object))) %>%
  ungroup() %>%
  summarize(mean = mean(n.objects), 
            median = median(n.objects), 
            sd = sd(n.objects), 
            min = min(n.objects),
            max = max(n.objects)) %>%
  mutate(across(mean:sd), round(., 2))

# ... by kid (incl. site info)
daily.objects.bysite <- data %>%
  group_by(sub_num, site) %>%
  summarize(n.objects = length(unique(object))) 

# t-test assumptions not met -> use wilcox
shapiro.test(subset(daily.objects.bysite,
                    daily.objects.bysite$site == "Rossel")$n.objects)
shapiro.test(subset(daily.objects.bysite,
                    daily.objects.bysite$site == "Tseltal")$n.objects)
var.test(n.objects ~ site, daily.objects.bysite)
comp.daily.objects <- tidy(wilcox.test(n.objects ~ site, daily.objects.bysite))

# compute most items that appear 1+ times most frequently
# across children w/i site
ranked.objects.list <- list()
for (i in sites) {
  ranked.objects <- data %>%
    filter(site == i) %>%
    mutate(total.kids = length(unique(sub_num))) %>%
    group_by(object, total.kids) %>%
    summarize(n.kids = length(unique(sub_num))) %>%
    mutate(prop = n.kids/total.kids) %>%
    ungroup() %>%
    arrange(desc(prop)) %>%
    mutate(rank = row_number(), 
           site = i) 
  ranked.objects.list[[i]] <- ranked.objects
}
all.ranked.objects <- do.call(rbind, ranked.objects.list)

ros.objects <- all.ranked.objects %>%
  filter(site == "Rossel") %>%
  pull(object)

tse.objects <- all.ranked.objects %>%
  filter(site == "Tseltal") %>%
  pull(object)

ros.top.objects <- all.ranked.objects %>%
  filter(site == "Rossel" & rank <= 25) %>%
  pull(object)

tse.top.objects <- all.ranked.objects %>%
  filter(site == "Tseltal" & rank <= 25) %>%
  pull(object)
```

<!-- kc: need to add trailing zeros after rounding; mc2kc: try something like: printnum(YOURNUM, digits = 3). i tried using format() before but it didn't work and i can't remember why heh--> Children handled an average of `r daily.objects$mean` unique objects per day (median = `r daily.objects$median`, _SD_ = `r daily.objects$sd`, range = `r daily.objects$min`--`r daily.objects$max`), with no significant differences across sites (_M_~_Rossel_~ = `r round(mean(subset(daily.objects.bysite, daily.objects.bysite$site == "Rossel")$n.objects), 2)`, _M_~_Tseltal_~ = `r round(mean(subset(daily.objects.bysite, daily.objects.bysite$site == "Tseltal")$n.objects), 2)`, _W_ = `r comp.daily.objects$statistic`, _p_ = `r round(comp.daily.objects$p.value, 3)`). Of these, `r round(length(intersect(ros.objects, tse.objects))/length(unique(raw.data$object)),4)*100`% of objects were present in both communities, and several shared objects were among the most frequently handled by children in both sites. In fact, among the top 25 most common objects, `r length(intersect(ros.top.objects, tse.top.objects))` were shared across sites.

```{r, overall-category-stats}
# compute the prevalence of category-level objects within kids (i.e.,
# proportion of holding by category for each kid)
category.props <- data %>%
  # TO DO: figure out where NAs are introduced
  filter(!is.na(object_type)) %>% # mc2kc: done? i can't find NAs
  group_by(sub_num, object_type, site) %>%
  summarize(n.category = n()) %>%
  distinct() %>% # mc2kc: i think this isn't doing anything
  ungroup() %>% 
  group_by(sub_num, site) %>%
  summarize(n.images = sum(n.category), 
            n.category = n.category,
            object_type = object_type) %>%
  mutate(prop = n.category/n.images) %>%
  distinct() # mc2kc: i think this isn't doing anything
  
# test for differences between sites for each category
wilcox.outputs <- list()
# TO DO: decide about immovable category
for (i in categories) {
  ros.input <- category.props %>%
    filter(object_type == i & site == "Rossel")
  
  tse.input <- category.props %>%
    filter(object_type == i & site == "Tseltal")
  
  wilcox.output <- tidy(wilcox.test(ros.input$prop, tse.input$prop))
  
  wilcox.outputs[[i]] <- wilcox.output
}

comp.category.bysite <- do.call(rbind, wilcox.outputs) %>%
  rownames_to_column(var = "object_type") %>%
  mutate(p.adjusted = p.adjust(p.value, method = "holm"))

# compute descriptive statistics of category prevalence by site and category
category.means <- category.props %>%
  group_by(object_type, site) %>%
  summarize(mean = mean(prop), 
            sd = sd(prop), 
            n = n(), 
            se = sd/sqrt(n))

# computer # kids with synthetic or food as their top type
top.category.bychild <- category.props %>%
  group_by(sub_num) %>%
  filter(prop == max(prop) & object_type %in% c("Synthetic", "Food")) %>%
  nrow()

# pull out the top synthetic category objects
top.synthetic <- data %>%
  filter(object_type == "Synthetic") %>%
  group_by(object) %>%
  summarize(n = n()) %>%
  arrange(desc(n)) %>%
  slice(1:3) %>%
  transmute(top.objects = paste(object, collapse = ", ")) %>%
  distinct() %>%
  pull(top.objects)

# pull out the top immovable category objects
top.immovable <- data %>%
  filter(object_type == "Immovable") %>%
  group_by(object) %>%
  summarize(n = n()) %>%
  arrange(desc(n)) %>%
  slice(1:3) %>%
  transmute(top.objects = paste(object, collapse = ", ")) %>%
  distinct() %>%
  pull(top.objects)

# compute mean # of categories per hour overall
# (first over subs, then over sample)
hourly.categories <- data %>%
  group_by(sub_num, hour) %>%
  summarize(n.categories = length(unique(object_type))) %>%
  ungroup() %>%
  summarize(mean = round(mean(n.categories), 2))
```

The frequency of object categories was similarly divided across sites (Figure 1A). The top objects for each category are shown in Table 1. Children primarily handled miscellaneous synthetic objects (e.g., `r top.synthetic`, etc.; _M_~_Rossel_~ = `r round(subset(category.means, site == "Rossel" & object_type == "Synthetic")$mean, 4)*100`% of handling, _M_~_Tseltal_~ = `r round(subset(category.means, site == "Tseltal" & object_type == "Synthetic")$mean, 4)*100`%) and food (_M_~_Rossel_~ = `r round(subset(category.means, site == "Rossel" & object_type == "Food")$mean, 4)*100`%, _M_~_Tseltal_~ = `r round(subset(category.means, site == "Tseltal" & object_type == "Food")$mean, 4)*100`%). For `r top.category.bychild` of `r length(unique(raw.data$sub_num))` children, the top category was either synthetic objects or food. Two-tailed Wilcoxon tests revealed only one significant category-level difference between sites: children's handling of large or immovable objects (e.g., `r top.immovable`, etc.), where Rossel children handled these objects more frequently than Tseltal children (_M_~_Rossel_~ = `r round(subset(category.means, site == "Rossel" & object_type == "Immovable")$mean, 4)*100`%, _M_~_Tseltal_~ = `r round(subset(category.means, site == "Tseltal" & object_type == "Immovable")$mean, 4)*100`%, adjusted _p_ = `r round(subset(comp.category.bysite, object_type == "Immovable")$p.adjusted, 3)`, *p*s for all other categories > 0.05), but these objects were still the least frequently handled in both sites.
<!--mc2kc: adjusted value is >.05 for all categories unless i'm missing things!-->

```{r, hourly-object-stats}
# compute mean # objects per hour overall
# (first over subs, then over sample)
hourly.objects <- data %>%
  group_by(sub_num, hour) %>%
  summarize(n.objects = length(unique(object))) %>%
  ungroup() %>%
  summarize(mean = mean(n.objects), 
            median = median(n.objects), 
            sd = sd(n.objects), 
            min = min(n.objects),
            max = max(n.objects)) %>%
  mutate(across(mean:sd), round(., 2))

# prep tibble for model w/ dummy coded category cols
# TO DO: deal with kids with 2 recordings
model.data <- data %>%
  group_by(site, sub_num, hour, object_type) %>%
  summarize(n.objects = length(unique(object))) %>%
  ungroup() %>%
  mutate(synthetic = ifelse(object_type == "Synthetic", 1, 0), 
         natural = ifelse(object_type == "Natural", 1, 0), 
         food = ifelse(object_type == "Food", 1, 0), 
         tool = ifelse(object_type == "Tool", 1, 0), 
         toy = ifelse(object_type == "Toy", 1, 0), 
         immovable = ifelse(object_type == "Immovable", 1, 0))

# run lmers
# check reference levels
model.data$object_type <- relevel(model.data$object_type, ref = "Synthetic")
ref.synthetic <- lmer(n.objects ~ site * object_type + (1|sub_num), model.data)

model.data$object_type <- relevel(model.data$object_type, ref = "Natural")
ref.natural <- lmer(
  n.objects ~ site * object_type + (1|sub_num), model.data) %>%
  tidy() %>%
  filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.05) %>%
  mutate(term = str_remove_all(term, "Tseltal"))

model.data$object_type <- relevel(model.data$object_type, ref = "Food")
ref.food <- lmer(n.objects ~ site * object_type + (1|sub_num), model.data) %>%
  tidy() %>%
  filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.05) %>%
  mutate(term = str_remove_all(term, "Tseltal"))

model.data$object_type <- relevel(model.data$object_type, ref = "Tool")
ref.tool <- lmer(n.objects ~ site * object_type + (1|sub_num), model.data) %>%
  tidy() %>%
  filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.05) %>%
  mutate(term = str_remove_all(term, "Tseltal"))

model.data$object_type <- relevel(model.data$object_type, ref = "Toy")
ref.toy <- lmer(n.objects ~ site * object_type + (1|sub_num), model.data) %>%
  tidy() %>%
  filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.05) %>%
  mutate(term = str_remove_all(term, "Tseltal"))

model.data$object_type <- relevel(model.data$object_type, ref = "Immovable")
ref.immovable <- lmer(
  n.objects ~ site * object_type + (1|sub_num), model.data) %>%
  tidy() %>%
  filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.05) %>%
  mutate(term = str_remove_all(term, "Tseltal"))

hourly.objects.model <- lmer(n.objects ~ site + 
                               synthetic + site:synthetic +
                               natural + site:natural + 
                               food + site:food +
                               tool + site:tool +
                               toy + site:toy +
                               immovable + site:immovable +
                               (1|sub_num), model.data) %>%
  tidy() %>% 
  filter(effect == "fixed" & term != "(Intercept)") %>%
  mutate(term = str_remove_all(term, "Tseltal"), 
         p.value = ifelse(p.value < .001, "< 0.001", round(p.value, 3)))

# compute mean rate of objects/hr per category per kid
hourly.objects.bycategory <- model.data %>%
  group_by(site, sub_num, object_type) %>%
  summarize(n.objects.bysub = mean(n.objects)) %>%
  ungroup() %>%
  mutate(object_type = factor(object_type,
                              levels = categories))
```

During any given hour, children handled `r hourly.objects$mean` objects from `r hourly.categories$mean` different categories, on average (median = `r hourly.objects$median` objects, _SD_ = `r hourly.objects$sd`, range = `r hourly.objects$min`--`r hourly.objects$max`). A linear mixed-effects model with fixed effects of site, each of the six object categories, and their interaction showed a significant main effect of the synthetic object category ($\beta$ = `r round(subset(hourly.objects.model, term == "synthetic")$estimate, 2)`, _SE_ = `r round(subset(hourly.objects.model, term == "synthetic")$std.error, 2)`, _t_ = `r round(subset(hourly.objects.model, term == "synthetic")$statistic, 2)`, _p_ = `r subset(hourly.objects.model, term == "synthetic")$p.value`) as well as an interaction between site and the synthetic object category ($\beta$ = `r round(subset(hourly.objects.model, term == "site:synthetic")$estimate, 2)`, _SE_ = `r round(subset(hourly.objects.model, term == "site:synthetic")$std.error, 2)`, _t_ = `r round(subset(hourly.objects.model, term == "site:synthetic")$statistic, 2)`, _p_ = `r subset(hourly.objects.model, term == "site:synthetic")$p.value`) such that children handled more unique synthetic objects per hour than any other object category, and this effect was stronger for Tseltal children than for Rossel children (*p*s > 0.05 for all other main effects and interaction terms; Figure 1B).

<!--kc: might be too much but other things we could add are co-occurrences between categories (e.g., food and tools for mealtime) and another possible DV, the number transitions between different object types and/or categories per hour. this could be one way to get at some finer-grained temporal dynamics without fully coding object bouts.

mc2kc: i think we could get away without these for the current paper. if time allows for one, let's try for rate of transitions between objects. but also we can just let that go for now! the paper is already packed with results :)
-->

```{r overall-stats-fig, fig.env = "figure", fig.pos = "!ht", fig.align = "center", fig.width = 3.4, fig.height = 4.4, fig.cap = "(A) Overall frequency of handling by object category. Points reflect percentages for individual children. (B) Count of unique objects handled per hour by object category. Points reflect means for individual children across all hours of recording."}

p1 <- ggplot() +
  geom_bar(data = category.means, 
           mapping  = aes(
             x = object_type, y = mean*100, color = site, fill = site),
           stat = "identity", position = "dodge", alpha = 0.7, width = 0.75) + 
  geom_point(data = category.props,
             mapping = aes(
               x = object_type, y = prop*100, color = site, fill = site),
             position = position_jitterdodge(
               dodge.width = 0.75, jitter.width = 0.1), 
             size = 0.5, alpha = 0.25) +
  geom_errorbar(data = category.means,
                mapping = aes(x = object_type, ymin = (mean - se)*100, 
                              ymax = (mean + se)*100, group = site),
                position = position_dodge(width = 0.75), 
                width = 0.25, size = 0.5, color = "black") +
  annotate(geom = "text", label = "*", x = "Immovable", y = 20, size = 6) +
  scale_color_manual(values = site.colors) +
  scale_fill_manual(values = site.colors) +
  labs(x = "Object Categories", y = "% Handling",
       color = "Site", fill = "Site", tag = "A") +
  theme_classic(base_size = 8) +
  theme(axis.title.x = element_blank())

p1a <- p1 + theme(legend.position = "none", legend.direction = "horizontal", 
                  plot.tag = element_text(face = "bold"))

legend <- get_legend(p1 + theme(legend.position = "bottom"))

p2 <- ggplot(hourly.objects.bycategory,
             aes(x = object_type, y = n.objects.bysub,
                 color = site, fill = site)) +
  # geom_half_violin(alpha = 0.5, position = position_nudge(x = 0.5),
  #                  side = "r") +
  geom_point(position = position_jitterdodge(
    dodge.width = 0.75, jitter.width = 0.1), size = 0.5, alpha = 0.5) +
  geom_boxplot(width = 0.75, outlier.shape = NA,
               alpha = 0.5, color = "black") +
  annotate(geom = "text", label = "*", x = "Synthetic", y = 5, size = 6) +
    scale_color_manual(values = site.colors) +
  scale_fill_manual(values = site.colors) +
  labs(x = "Object Categories", y = "Unique Objects/Hour",
       color = "Site", fill = "Site", tag = "B") +
  theme_classic(base_size = 8) +
  theme(legend.position = "none", plot.tag = element_text(face = "bold"))

fig1 <- align_plots(p1a, p2, align = "hv", axis = "l")
panels <- plot_grid(ggdraw(fig1[[1]]), NULL,
                    ggdraw(fig1[[2]]), nrow = 3, rel_heights = c(1, -0.07, 1))
plot_grid(panels, legend, ncol = 1, rel_heights = c(1, .1))
```

## Time of day effects
```{r, time-of-day-categories}
# compute prop of images in each category for each hour for each kid
category.props.bytod <- data %>%
  group_by(sub_num, object_type, site, hour) %>%
  summarize(n.category = n()) %>%
  distinct() %>% # mc2kc: i think this isn't doing anything
  ungroup() %>% 
  group_by(sub_num, site, hour) %>%
  summarize(n.images = sum(n.category), 
            n.category = n.category, 
            object_type = object_type) %>%
  mutate(prop = n.category/n.images) %>%
  distinct() %>% # mc2kc: i think this isn't doing anything
  ungroup() %>%
  mutate(tod = hour, 
         object_type = factor(object_type,
                              levels = categories)) %>%
  filter(!is.na(object_type)) # mc2kc: no NAs :D
  
# model time of day effects w/ indiv models for each category
tod.effects.list <- list()
tod.effects.toplot.list <- list()
for (i in categories) {
  model <- lmer(prop ~ site * tod + (1|sub_num),
                filter(category.props.bytod, object_type == i))
  # note: singular fit for immovable category
  
  effects <- tidy(model) %>%
    mutate(object_type = i) %>%
    filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.10)
  
  # get predicted values from the model for plotting
  effects.toplot <- ggpredict(model,
                              terms = c("site", "tod [all]"),
                              type = "fixed", back.transform = TRUE) %>%
  rename(tod = group, site = x) %>%
  mutate(object_type = i)
  
  tod.effects.list[[i]] <- effects
  tod.effects.toplot.list[[i]] <- effects.toplot
}

tod.effects <- do.call(rbind, tod.effects.list)
tod.effects.toplot <- do.call(rbind, tod.effects.toplot.list) %>%
  mutate(object_type = factor(object_type,
                              levels = categories), 
         tod = as.numeric(as.character(tod)))
```

```{r, time-of-day-objects}
# compute number of unique objects per hour per kid
hourly.objects.bytod <- data %>%
  group_by(site, sub_num, hour) %>%
  summarize(n.objects = length(unique(object))) %>%
  ungroup() %>%
  mutate(tod = hour)

# model # unique objects by site and tod
model <- lmer(n.objects ~ site * tod + (1|sub_num), hourly.objects.bytod)

hourly.objects.bytod.effects <- tidy(model) %>%
  filter(effect == "fixed" & term != "(Intercept)") %>%
  mutate(term = str_remove_all(term, "Tseltal"))

# get model predicted values for plotting
hourly.objects.bytod.effects.toplot <- ggpredict(
  model, terms = c("site", "tod [all]"),
  type = "fixed", back.transform = TRUE) %>%
  rename(tod = group, site = x)
```

Children's overall rate of object handling was largely consistent across the day. The number of unique handled objects per hour was not linearly related to time of day ($\beta$ = `r round(subset(hourly.objects.bytod.effects, term == "tod")$estimate, 2)`, _SE_ = `r round(subset(hourly.objects.bytod.effects, term == "tod")$std.error, 2)`, _t_ = `r round(subset(hourly.objects.bytod.effects, term == "tod")$statistic, 2)`, _p_ = `r round(subset(hourly.objects.bytod.effects, term == "tod")$p.value, 3)`), and there was no two-way interaction between time of day and site ($\beta$ = `r round(subset(hourly.objects.bytod.effects, term == "site:tod")$estimate, 2)`, _SE_ = `r round(subset(hourly.objects.bytod.effects, term == "site:tod")$std.error, 2)`, _t_ = `r round(subset(hourly.objects.bytod.effects, term == "site:tod")$statistic, 2)`, _p_ = `r round(subset(hourly.objects.bytod.effects, term == "site:tod")$p.value, 3)`).

However, we did find differences in children's rates of holding for specific object categories across the day. We ran individual linear mixed-effects models, which included fixed effects of site, hour of the day, and their interaction, for each of the six categories. Synthetic objects were marginally more common during the afternoon hours ($\beta$ = `r round(subset(tod.effects, term == "tod" & object_type == "Synthetic")$estimate, 2)`, _SE_ = `r round(subset(tod.effects, term == "tod" & object_type == "Synthetic")$std.error, 2)`, _t_ = `r round(subset(tod.effects, term == "tod" & object_type == "Synthetic")$statistic, 2)`, _p_ = `r round(subset(tod.effects, term == "tod" & object_type == "Synthetic")$p.value, 3)`)<!--mc2kc: note these effects of synthetic aren't coming out anymore-->, and food items were handled with significantly greater frequency during the morning hours ($\beta$ = `r round(subset(tod.effects, term == "tod" & object_type == "Food")$estimate, 2)`, _SE_ = `r round(subset(tod.effects, term == "tod" & object_type == "Food")$std.error, 2)`, _t_ = `r round(subset(tod.effects, term == "tod" & object_type == "Food")$statistic, 2)`, _p_ = `r round(subset(tod.effects, term == "tod" & object_type == "Food")$p.value, 3)`; Figure 2). No other main effects or two-way interactions reached statistical significance (all *p*s > 0.05).

```{r tod-effects-fig, fig.env = "figure", fig.pos = "!ht", fig.align = "center", fig.width = 3.4, fig.height = 2.9, fig.cap = "Frequency of handling by object category across different times of day. Individual points show raw percentages per hour for each child, and lines reflect model-predicted percentages."}

ggplot(tod.effects.toplot,
       aes(x = tod, y = predicted*100, color = site, fill = site)) +
  facet_wrap(. ~ object_type, nrow = 2) +
  geom_line(size = 1) +
  # geom_ribbon(aes(ymin = predicted*100 - conf.low*100,
  #                 ymax = predicted*100 + conf.low*100, fill = site),
  #             color = NA, alpha = 0.1) +
  geom_jitter(category.props.bytod, mapping = aes(
    x = tod, y = prop*100, color = site, fill = site),
    alpha = 0.25, size = 0.5) +
  scale_fill_manual(values = site.colors) +
  scale_color_manual(values = site.colors) +
  scale_x_continuous(breaks = c(8, 12, 16), labels = c("8AM", "12PM", "4PM")) +
  labs(x = "Time of Day", y = "% Handling", color = "Site", fill = "Site") +
  theme_test(base_size = 8) +
  theme(legend.position = "none")
```

## Age effects
```{r, age-objects}
# calculate total # unique objects per kid
daily.objects.byage <- data %>%
  group_by(site, sub_num, age) %>%
  summarize(n.objects = length(unique(object))) %>%
  ungroup()

# model total # unique objects handled by site and age
model <- lm(n.objects ~ site * age, daily.objects.byage)

daily.objects.byage.effects <- tidy(model) %>%
    filter(term != "(Intercept)" & p.value < 0.10)

# get model predicted values for plotting
daily.objects.byage.effects.toplot <- ggpredict(
  model, terms = c("site", "age [all]"),
  type = "fixed", back.transform = TRUE) %>%
  rename(age = group, site = x)

# calculate # unique objects per hour per kid
hourly.objects.byage <- data %>%
  group_by(site, sub_num, age, hour) %>%
  summarize(n.objects = length(unique(object))) %>%
  ungroup()

# model total # unique objects handled per hour by site and age
model <- lmer(n.objects ~ site * age + (1|sub_num), hourly.objects.byage)

# marginal increase in unique objects per hour with age
hourly.objects.byage.effects <- tidy(model) %>%
    filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.10)

# get model predicted values for plotting
hourly.objects.byage.effects.toplot <- ggpredict(
  model, terms = c("site", "age [all]"), type = "fixed",
  back.transform = TRUE) %>%
  rename(age = group, site = x) %>%
  mutate(age = as.numeric(as.character(age)))
```

```{r, age-categories}
# calculate total # objects per category and prop objects per category, per kid
category.props.byage <- data %>%
  group_by(sub_num, object_type, site, age) %>%
  summarize(n.category = n()) %>%
  distinct() %>% # mc2kc: i think this isn't doing anything
  ungroup() %>% 
  group_by(sub_num, site, age) %>%
  summarize(n.images = sum(n.category), 
            n.category = n.category, 
            object_type = object_type) %>%
  mutate(prop = n.category/n.images) %>%
  ungroup() %>%
  mutate(object_type = factor(object_type,
                              levels = categories))
  
# model proportion of object handling by site and age
age.effects.list <- list()
age.effects.toplot.list <- list()
for (i in categories) {
  model <- lm(prop ~ site * age,
              filter(category.props.byage, object_type == i))
  
  effects <- tidy(model) %>%
    mutate(object_type = i) %>%
    filter(term != "(Intercept)" & p.value < 0.10)
  
  # get model predicted values for plotting
  effects.toplot <- ggpredict(model, terms = c("site", "age [all]"),
                              type = "fixed", back.transform = TRUE) %>%
  rename(age = group, site = x) %>%
  mutate(object_type = i)
  
  age.effects.list[[i]] <- effects
  age.effects.toplot.list[[i]] <- effects.toplot
}

age.effects <- do.call(rbind, age.effects.list)
age.effects.toplot <- do.call(rbind, age.effects.toplot.list) %>%
  mutate(object_type = factor(object_type,
                              levels = categories))

# compute # unique categories per hour per kid
hourly.categories.byage <- data %>%
  group_by(site, sub_num, age, hour) %>%
  summarize(n.categories = length(unique(object_type))) %>%
  ungroup()

# model # categories per hour by site and age
model <- lmer(n.categories ~ site * age + (1|sub_num), hourly.categories.byage)

# marginal increase in unique objects per hour with age
hourly.categories.byage.effects <- tidy(model) %>%
    filter(effect == "fixed" & term != "(Intercept)" & p.value < 0.10)

# get model predicted values for plotting
hourly.categories.byage.effects.toplot <- ggpredict(
  model, terms = c("site", "age [all]"), type = "fixed",
  back.transform = TRUE) %>%
  rename(age = group, site = x) %>%
  mutate(age = as.numeric(as.character(age)))

# compute # unique categories per hour per kid
# TO DO: deal with multiple objects and thus categories per image
# (for simplicity now marked as "Multiple" but will fix after manual checking)
hourly.total.categories <- data %>%
  group_by(sub_num, hour) %>%
  summarize(n.categories = length(unique(object_type)))

# compute # of transitions between objects per hour per kid
# and number of transitions per object per hour per kid ("rel.transitions")
hourly.category.transitions <- data %>%
  group_by(sub_num, image) %>%
  # first calculate # objects per image
  mutate(n.categories = length(unique(object_type))) %>%
  distinct() %>% # mc2kc: i think this isn't doing anything
  ungroup() %>%
  # second, add cols w/ prev object and check if there's been a change
  # in held object---if so, mark it as a transition == 1
  mutate(category = ifelse(n.categories > 1, "Multiple", object_type), 
         prev.category = lag(category, 1), 
         same.child = ifelse(sub_num == lag(sub_num, 1), 1, 0), 
         transition = ifelse(category != prev.category &
                               same.child == 1, 1, 0)) %>%
  group_by(site, sub_num, age, hour) %>%
  summarize(n.transitions = sum(transition, na.rm = TRUE)) %>%
  left_join(hourly.total.categories, by = c("sub_num", "hour")) %>%
  mutate(rel.transitions = n.transitions/n.categories)

# model rel.transitions by site and age
model <- lmer(rel.transitions ~ site * age + (1|sub_num),
              hourly.category.transitions)
```

Children's overall rate of object handling increased significantly with age (Figure 3A). That is, older children handled more unique objects per hour ($\beta$ = `r round(subset(hourly.objects.byage.effects, term == "age")$estimate, 2)`, _SE_ = `r round(subset(hourly.objects.byage.effects, term == "age")$std.error, 2)`, _t_ = `r round(subset(hourly.objects.byage.effects, term == "age")$statistic, 2)`, _p_ = `r round(subset(hourly.objects.byage.effects, term == "age")$p.value, 3)`). <!--kc: possibly add category distribution across age, which is generally consistent.--> Additionally, with increasing age, children handled more objects from different categories per hour ($\beta$ = `r round(subset(hourly.categories.byage.effects, term == "age")$estimate, 2)`, _SE_ = `r round(subset(hourly.categories.byage.effects, term == "age")$std.error, 2)`, _t_ = `r round(subset(hourly.categories.byage.effects, term == "age")$statistic, 2)`, _p_ = `r round(subset(hourly.categories.byage.effects, term == "age")$p.value, 3)`). <!--kc: need to check correlations between objects and categories. can also switch to proportions for categories if needed; mc2kc: sounds like a good idea to me!--> These effects were consistent across sites; we found no main effects of site or interactions between site and age (all *p*s > 0.05).

```{r age-effects-fig, fig.env = "figure", fig.pos = "!ht", fig.align = "center", fig.width = 3.4, fig.height = 4.4, fig.cap = "(A) Unique objects and (B) object categories handled per hour as a function of age. Points reflect raw hourly counts for each child, and lines reflect model predictions with shaded standard error regions."}

p1 <- ggplot() +
  geom_line(hourly.objects.byage.effects.toplot,
            mapping = aes(x = age, y = predicted, color = site), size = 1) +
  geom_ribbon(hourly.objects.byage.effects.toplot,
              mapping = aes(x = age , ymin = predicted - conf.low,
                            ymax = predicted + conf.low, fill = site),
              alpha = 0.1) +
  geom_jitter(hourly.objects.byage,
              mapping = aes(x = age, y = n.objects,
                            color = site, fill = site), 
              alpha = 0.25, size = 0.5) +
  scale_color_manual(values = site.colors) +
  scale_fill_manual(values = site.colors) +
  scale_x_continuous(breaks = c(0, 12, 24, 36, 48)) +
  labs(x = "Age (months)", y = "Unique Objects/Hour",
       color = "Site", fill = "Site", tag = "A") +
  theme_test(base_size = 8)

p1a <- p1 + theme(legend.position = "none", legend.direction = "horizontal", 
                  plot.tag = element_text(face = "bold"))

legend <- get_legend(p1 + theme(legend.position = "bottom"))

p2 <- ggplot() +
  geom_line(hourly.categories.byage.effects.toplot,
            mapping = aes(x = age, y = predicted, color = site), size = 1) +
  geom_ribbon(hourly.categories.byage.effects.toplot,
              mapping = aes(x = age , ymin = predicted - conf.low,
                            ymax = predicted + conf.low, fill = site),
              alpha = 0.1) +
  geom_jitter(hourly.categories.byage,
              mapping = aes(x = age, y = n.categories,
                            color = site, fill = site),
              alpha = 0.25, size = 0.5) +
  scale_color_manual(values = site.colors) +
  scale_fill_manual(values = site.colors) +
  scale_x_continuous(breaks = c(0, 12, 24, 36, 48)) +
  labs(x = "Age (months)", y = "Unique Categories/Hour",
       color = "Site", fill = "Site", tag = "B") +
  theme_test(base_size = 8) +
  theme(legend.position = "none", plot.tag = element_text(face = "bold"))

fig4 <- align_plots(p1a, p2, align = "hv", axis = "l")
panels <- plot_grid(ggdraw(fig4[[1]]), NULL,
                    ggdraw(fig4[[2]]), nrow = 3, rel_heights = c(1, -0.07, 1))
plot_grid(panels, legend, ncol = 1, rel_heights = c(1, .1))
```

# Discussion

# References 
<!-- need to rm 10 from start of refs-->

```{r}
# References will be generated automatically by Pandoc and included here.
# The following code is some latex to format the bibliography. Do not remove it.
```

\setlength{\parindent}{-0.1in} 
\setlength{\leftskip}{0.125in}
\noindent
